use crate::ast::*;
use crate::lexer::TokenKind;
use super::Ctx;

grammar<'a>(ctx: &Ctx<'a>);

pub Program: Program<'a> = {
    <start:@L> <stmt_list:StmtList> <end:@R> EofTok => Program { stmt_list },
}

StmtList: StmtList<'a> = {
    <start:@L> Lf? <stmts:(<Stmt>)*> <end:@R> => StmtList { span: ctx.span(start, end), stmts },
}

Stmt: Stmt<'a> = {
    <start:@L> <kind:StmtKind> <end:@R> => {
        Stmt { span: ctx.span(start, end), kind }
    }
}

StmtKind: StmtKind<'a> = {
    <Expr> Lf => StmtKind::Expr(<>),
    <VarDef> => StmtKind::VarDef(<>),
    <FuncDef> => StmtKind::FuncDef(<>),
    "pass" Lf => StmtKind::Pass,
}

Expr: Expr<'a> = {
    <start:@L> <kind:ExprKind> <end:@R> => {
        Expr { span: ctx.span(start, end), kind }
    }
}

ExprKind: ExprKind<'a> = {
    <Lit> => ExprKind::Lit(<>),
}

VarDef: VarDef<'a> = {
    "var" <IdentDef> Lf => {
        VarDef {
            def: <>,
        }
    }
}

FuncDef: FuncDef<'a> = {
    <start:@L> "func" <name:Ident> "(" <param_list:ParamList> ")" <result_ty:ResultSpec?> ":" Lf
    IndentTok <body:StmtList> DedentTok <end:@R> => {
        FuncDef { span: ctx.span(start, end), name, param_list, result_ty, body }
    }
}

ResultSpec: Expr<'a> = {
    "->" <Expr>
}

ParamList: ParamList<'a> = {
    <start:@L> <mut params:(<IdentDef> ",")*> <e:IdentDef?> <end:@R> => {
        if let Some(p) = e {
            params.push(p);
        }
        ParamList { span: ctx.span(start, end), params }
    }
}

IdentDef: IdentDef<'a> = {
    <start:@L> <name:Ident> <ty:(":" <Expr>)?> "=" <val:Expr?> <end:@R> => {
        if let Some(ty) = ty {
            IdentDef {
                span: ctx.span(start, end), name, ty: TySpec::Ty(ty), val,
            }
        } else {
            IdentDef {
                span: ctx.span(start, end), name, ty: TySpec::Any, val,
            }
        }
    },
    <start:@L> <name:Ident> ":" "=" <val:Expr> <end:@R> => {
        IdentDef {
            span: ctx.span(start, end), name, ty: TySpec::Inferred, val: Some(val),
        }
    }
}

Ident: Ident<'a> = {
    <start:@L> IdentTok <end:@R> => {
        let s = ctx.src(start..end);
        Ident { span: ctx.span(start, end), name: ctx.ident_cache.new_ident_name(s) }
    }
}

Lit: Lit = {
    <IntLit> => Lit::Int(<>),
}

IntLit: i128 = {
    <start:@L> IntLitTok <end:@R> => {
        let s = ctx.src(start..end);
        i128::from_str_radix(s, 10).unwrap()
    }
}

extern {
    type Location = u32;
    type Error = ();

    enum TokenKind {
        AnnotationTok => TokenKind::Annotation,
        IdentTok => TokenKind::Ident,
        IntLitTok => TokenKind::IntLit,
        StrLitTok => TokenKind::StrLit,
        "<" => TokenKind::Less,
        "<=" => TokenKind::LessEqual,
        ">" => TokenKind::Greater,
        ">=" => TokenKind::GreaterEqual,
        "==" => TokenKind::EqualEqual,
        "!=" => TokenKind::BangEqual,
        "and" => TokenKind::And,
        "or" => TokenKind::Or,
        "not" => TokenKind::Not,
        "&&" => TokenKind::AmpAmp,
        "||" => TokenKind::PipePipe,
        "!" => TokenKind::Bang,
        "&" => TokenKind::Amp,
        "|" => TokenKind::Pipe,
        "~" => TokenKind::Tilde,
        "^" => TokenKind::Caret,
        "<<" => TokenKind::LessLess,
        ">>" => TokenKind::GreaterGreater,
        "+" => TokenKind::Plus,
        "-" => TokenKind::Minus,
        "*" => TokenKind::Star,
        "**" => TokenKind::StarStar,
        "/" => TokenKind::Slash,
        "%" => TokenKind::Percent,
        "=" => TokenKind::Equal,
        "+=" => TokenKind::PlusEqual,
        "-=" => TokenKind::MinusEqual,
        "*=" => TokenKind::StarEqual,
        "**=" => TokenKind::StarStarEqual,
        "/=" => TokenKind::SlashEqual,
        "%=" => TokenKind::PercentEqual,
        "<<=" => TokenKind::LessLessEqual,
        ">>=" => TokenKind::GreaterGreaterEqual,
        "&=" => TokenKind::AmpEqual,
        "|=" => TokenKind::PipeEqual,
        "^=" => TokenKind::CaretEqual,
        "if" => TokenKind::If,
        "elif" => TokenKind::Elif,
        "else" => TokenKind::Else,
        "for" => TokenKind::For,
        "while" => TokenKind::While,
        "break" => TokenKind::Break,
        "continue" => TokenKind::Continue,
        "pass" => TokenKind::Pass,
        "return" => TokenKind::Return,
        "match" => TokenKind::Match,
        "when" => TokenKind::When,
        "as" => TokenKind::As,
        "assert" => TokenKind::Assert,
        "await" => TokenKind::Await,
        "breakpoint" => TokenKind::Breakpoint,
        "class" => TokenKind::Class,
        "class_name" => TokenKind::ClassName,
        "const" => TokenKind::Const,
        "enum" => TokenKind::Enum,
        "extends" => TokenKind::Extends,
        "func" => TokenKind::Func,
        "in" => TokenKind::In,
        "is" => TokenKind::Is,
        "namespace" => TokenKind::Namespace,
        "preload" => TokenKind::Preload,
        "self" => TokenKind::Self_,
        "signal" => TokenKind::Signal,
        "static" => TokenKind::Static,
        "super" => TokenKind::Super,
        "trait" => TokenKind::Trait,
        "var" => TokenKind::Var,
        "void" => TokenKind::Void,
        "yield" => TokenKind::Yield,
        "[" => TokenKind::BracketOpen,
        "]" => TokenKind::BracketClose,
        "{" => TokenKind::BraceOpen,
        "}" => TokenKind::BraceClose,
        "(" => TokenKind::ParenthesisOpen,
        ")" => TokenKind::ParenthesisClose,
        "," => TokenKind::Comma,
        ";" => TokenKind::SemiColon,
        "." => TokenKind::Period,
        ".." => TokenKind::PeriodPeriod,
        ":" => TokenKind::Colon,
        "$" => TokenKind::Dollar,
        "->" => TokenKind::ForwardArrow,
        "_" => TokenKind::Underscore,
        Lf => TokenKind::Newline,
        IndentTok => TokenKind::Indent,
        DedentTok => TokenKind::Dedent,
        EofTok => TokenKind::Eof,
    }
}
